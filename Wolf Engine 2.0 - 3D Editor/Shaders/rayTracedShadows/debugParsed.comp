#version 460

layout(binding = 0, set = 1) uniform UniformBufferCamera
{
	mat4 view;

	mat4 projection;

	mat4 invView;

	mat4 invProjection;

	mat4 previousViewMatrix;

	vec2 jitter;
	vec2 projectionParams;

	float near;
	float far;
	
} ubCamera;

mat4 getViewMatrix()
{
	return ubCamera.view;
}

mat4 getProjectionMatrix()
{
	return ubCamera.projection;
}

mat4 getInvViewMatrix()
{
	return ubCamera.invView;
}

mat4 getInvProjectionMatrix()
{
	return ubCamera.invProjection;
}

vec2 getProjectionParams()
{
	return ubCamera.projectionParams;
}

vec2 getCameraJitter()
{
	return ubCamera.jitter;
}

float linearizeDepth(float d)
{
    return ubCamera.near * ubCamera.far / (ubCamera.far - d * (ubCamera.far - ubCamera.near));
}

mat4 getPreviousViewMatrix()
{
	return ubCamera.previousViewMatrix;
}

vec3 computeWorldPosFromViewPos(in const vec3 viewPos)
{
	return (getInvViewMatrix() * vec4(viewPos, 1.0)).xyz;
}
#extension GL_EXT_samplerless_texture_functions : require

layout (binding = 0, rgba8) uniform image2D outputImage;
layout (binding = 1, rg32f) uniform image2D denoisingSamplingPattern;
layout (binding = 2, std140) uniform UniformBuffer
{
    vec3 worldSpaceNormal;
    vec2 pixelUV;
    vec2 patternSize;
    vec2 outputImageSize;
} ub;
layout (binding = 3) uniform texture2D depthImage;

#include "denoising.glsl"

const uint LOCAL_SIZE = 16;
layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
    if (gl_GlobalInvocationID.x > ub.patternSize.x)
        return;

    vec2 d = ub.pixelUV * 2.0 - 1.0;
    vec4 viewRay = getInvProjectionMatrix() * vec4(d.x, d.y, 1.0, 1.0);
    float depth = texelFetch(depthImage, ivec2(ub.pixelUV * ub.outputImageSize), 0).r;
    float linearDepth = getProjectionParams().y / (depth - getProjectionParams().x);
    vec3 viewPos = viewRay.xyz * linearDepth;
    vec3 refWorldPos = (getInvViewMatrix() * vec4(viewPos, 1.0f)).xyz;

    computeSamplePositions(ub.worldSpaceNormal, refWorldPos, getInvViewMatrix(), getViewMatrix(), getProjectionMatrix());

    imageStore(outputImage, ivec2(samplesTexturePos[gl_GlobalInvocationID.x] * ub.outputImageSize), mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 1.0, 0.0, 1.0), sampleWeight[gl_GlobalInvocationID.x]));
}
