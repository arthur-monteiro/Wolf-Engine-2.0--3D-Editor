#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : require

layout (binding = 0, set = 0, rgba16f) uniform readonly image2D forwardOutputImage;
layout (binding = 1, set = 0, rgba8) uniform readonly image2D uiOutputImage;
layout (binding = 2, set = 0) uniform sampler3D inputLUT;
layout (binding = 3, set = 0, std140) uniform readonly UniformBuffer
{
    uint displayType;
	float lutTexelSize;
    uint renderOffsetX;
    uint renderOffsetY;

    uint renderSizeX;
    uint renderSizeY;
} ub;
layout (binding = 4, set = 0, OUTPUT_FORMAT) uniform image2D displayOutputImage;

#include "../common/colorSpaceTransformations.glsl"
#include "../common/displayTypes.glsl"

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve
vec3 ACESFilm(vec3 x) 
{
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;

    vec3 outValue = (x * (a * x + b)) / (x * (c * x + d) + e);
    return clamp(outValue, 0.0, 1.0);
}

const uint LOCAL_SIZE = 16;
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;
void main()
{
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    vec3 forwardColor = imageLoad(forwardOutputImage, coords).rgb;
    vec4 uiColor = imageLoad(uiOutputImage, coords).rgba;

    if (ub.displayType == DISPLAY_TYPE_LIGHTING && coords.x > ub.renderOffsetX && coords.x < ub.renderOffsetX + ub.renderSizeX && coords.y > ub.renderOffsetY && coords.y < ub.renderOffsetY + ub.renderSizeY)
    {
        forwardColor = ACESFilm(forwardColor);

        // Color grading
        vec3 lutCoords = mix(vec3(ub.lutTexelSize / 2.0), vec3(1.0 - ub.lutTexelSize / 2.0), linearToSRGB(forwardColor));
        forwardColor = srgbToLinear(texture(inputLUT, lutCoords).rgb);
    }

    vec3 finalColor = forwardColor * (1.0 - uiColor.a) + srgbToLinear(uiColor.bgr) * uiColor.a;

#if USE_LINEAR
    const float BRIGHTNESS_SCALE = 2.5;
    finalColor *= BRIGHTNESS_SCALE;
#else
    finalColor = linearToSRGB(clamp(finalColor, 0.0, 1.0));
#endif

    imageStore(displayOutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 1.0));
}