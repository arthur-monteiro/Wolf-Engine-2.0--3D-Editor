#extension GL_EXT_ray_tracing : require
#extension GL_EXT_samplerless_texture_functions : require

#include "payloads.glsl"
layout(location = 0) rayPayloadEXT Payload payload;

layout(std430, binding = 0, set = 0) buffer VertexBufferLayout
{
    uint data[];
} vertexBuffer;

layout(std430, binding = 1, set = 0) buffer IndexBufferLayout
{
    uint indices[];
} indexBuffer;

layout(binding = 2, set = 0) uniform UniformBuffer
{
    uint indexCount;
    vec3 padding;
} ub;

layout(std430, binding = 3, set = 0) buffer RandomSamplesBufferLayout
{
    vec2 samples[];
} randomSamplesBuffer;

layout(std430, binding = 4, set = 0) buffer ColorWeightBufferLayout
{
    uint weights[];
} colorWeightsBuffer;

vec3 getRandomPointInTriangle(int index, vec3 p0, vec3 p1, vec3 p2) 
{
    float u = randomSamplesBuffer.samples[index].x;
    float v = randomSamplesBuffer.samples[index].y;

    if (u + v > 1.0) 
    {
        u = 1.0 - u;
        v = 1.0 - v;
    }

    float alpha = u;
    float beta = v;
    float gamma = 1.0 - alpha - beta; // gamma >= 0 since u+v <= 1

    vec3 p = (alpha * p0) + (beta * p1) + (gamma * p2);

    return p;
}

vec3 getVertexPositionAtIndex(in uint index)
{
    uint offset = index * vertexSize;
    vec3 position;
    position.x = uintBitsToFloat(vertexBuffer.data[offset + 0]);
    position.y = uintBitsToFloat(vertexBuffer.data[offset + 1]);
    position.z = uintBitsToFloat(vertexBuffer.data[offset + 2]);

    return position;
}

void atomicVertexBufferFloatAdd(in int bufferIndex, float value) 
{
    for (;;) 
    {        
        uint oldBits = atomicCompSwap(vertexBuffer.data[bufferIndex], 0, 0);

        float oldFloat = uintBitsToFloat(oldBits);
        float newFloat = oldFloat + value;
        uint newBits = floatBitsToUint(newFloat);

        if (atomicCompSwap(vertexBuffer.data[bufferIndex], oldBits, newBits) == oldBits) 
        {
            break;
        }
    }
}

void atomicWeightAdd(in uint bufferIndex, float value) 
{
    for (;;) 
    {
        uint oldBits = atomicCompSwap(colorWeightsBuffer.weights[bufferIndex], 0, 0);

        float oldFloat = uintBitsToFloat(oldBits);
        float newFloat = oldFloat + value;

        uint newBits = floatBitsToUint(newFloat);

        if (atomicCompSwap(colorWeightsBuffer.weights[bufferIndex], oldBits, newBits) == oldBits) 
        {
            break;
        }
    }
}


void addVertexColorAtIndex(in uint index, in vec3 color)
{
    uint offset = index * vertexSize;
    atomicVertexBufferFloatAdd(int(offset + 3), color.x);
    atomicVertexBufferFloatAdd(int(offset + 4), color.y);
    atomicVertexBufferFloatAdd(int(offset + 5), color.z);
}

float triangleArea(in vec3 v0, in vec3 v1, in vec3 v2)
{
    vec3 sideA = v1 - v0;
    vec3 sideB = v2 - v0;
    
    vec3 crossProduct = cross(sideA, sideB);
    float area = 0.5 * length(crossProduct);
    
    return area;
}

void main() 
{
    uint index = indexBuffer.indices[gl_LaunchIDEXT.x];

    // Compute triangle normal
    uint firstTriangleIndexNumber = gl_LaunchIDEXT.x - gl_LaunchIDEXT.x % 3;

    uint index0 = indexBuffer.indices[firstTriangleIndexNumber];
    vec3 vertexPosition0 = getVertexPositionAtIndex(index0);

    uint index1 = indexBuffer.indices[firstTriangleIndexNumber + 1];
    vec3 vertexPosition1 = getVertexPositionAtIndex(index1);

    uint index2 = indexBuffer.indices[firstTriangleIndexNumber + 2];
    vec3 vertexPosition2 = getVertexPositionAtIndex(index2);

    vec3 triangleNormal = computeTriangleNormal(vertexPosition0, vertexPosition1, vertexPosition2);


    // Compute vertex color
    vec3 triangleColor = vec3(0.0);

    vec3 direction = -normalize(triangleNormal);
    for (int i = 0; i < 32; i++)
    {
        vec3 position = getRandomPointInTriangle(i, vertexPosition0, vertexPosition1, vertexPosition2);

        uint rayFlags = gl_RayFlagsCullBackFacingTrianglesEXT;
        uint cullMask = 0xff;
        float tmin = 0.001;
        float tmax = 0.5;
        traceRay(rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, position - direction * tmax * 0.5, tmin, direction, tmax);

        if (payload.hasHit)
        {
            triangleColor += payload.albedo;
        }
        else
        {
        }
    }

    float weight = triangleArea(vertexPosition0, vertexPosition1, vertexPosition2);
    addVertexColorAtIndex(index, (triangleColor / 32.0) * weight);
    atomicWeightAdd(index, weight);
}