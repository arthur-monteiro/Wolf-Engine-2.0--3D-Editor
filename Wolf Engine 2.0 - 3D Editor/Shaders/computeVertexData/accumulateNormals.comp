layout(std430, binding = 0, set = 0) buffer VertexBufferLayout
{
    uint data[];
} vertexBuffer;

layout(std430, binding = 1, set = 0) buffer IndexBufferLayout
{
    uint indices[];
} indexBuffer;

layout(binding = 2, set = 0) uniform uniformBuffer
{
    uint indexCount;
    vec3 padding;
} ub;

const uint VERTEX_SIZE = 15;

vec3 getVertexPositionAtIndex(in uint index)
{
    uint offset = index * VERTEX_SIZE;
    vec3 position;
    position.x = uintBitsToFloat(vertexBuffer.data[offset + 0]);
    position.y = uintBitsToFloat(vertexBuffer.data[offset + 1]);
    position.z = uintBitsToFloat(vertexBuffer.data[offset + 2]);

    return position;
}

void atomicFloatAdd(in int bufferIndex, float value) 
{
    for (;;) 
    {
        uint oldBits = atomicCompSwap(vertexBuffer.data[bufferIndex], 0, 0);

        float oldFloat = uintBitsToFloat(oldBits);
        float newFloat = oldFloat + value;
        uint newBits = floatBitsToUint(newFloat);

        if (atomicCompSwap(vertexBuffer.data[bufferIndex], oldBits, newBits) == oldBits) 
        {
            break;
        }
    }
}

void addVertexNormalAtIndex(in uint index, in vec3 normal)
{
    uint offset = index * VERTEX_SIZE;
    atomicFloatAdd(int(offset + 6), normal.x);
    atomicFloatAdd(int(offset + 7), normal.y);
    atomicFloatAdd(int(offset + 8), normal.z);
}

vec3 computeTriangleNormal(vec3 p1, vec3 p2, vec3 p3) 
{
    // Edge vectors
    vec3 A = p2 - p1;
    vec3 B = p3 - p1;

    vec3 normal = cross(A, B);
    return normalize(normal);
}

float triangleArea(in vec3 v0, in vec3 v1, in vec3 v2)
{
    vec3 sideA = v1 - v0;
    vec3 sideB = v2 - v0;
    
    vec3 crossProduct = cross(sideA, sideB);
    float area = 0.5 * length(crossProduct);
    
    return area;
}

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main()
{
    if (gl_GlobalInvocationID.x >= ub.indexCount)
        return;

    uint index = indexBuffer.indices[gl_GlobalInvocationID.x];

    // Compute triangle normal
    uint firstTriangleIndexNumber = gl_GlobalInvocationID.x - gl_GlobalInvocationID.x % 3;

    uint index0 = indexBuffer.indices[firstTriangleIndexNumber];
    vec3 vertexPosition0 = getVertexPositionAtIndex(index0);

    uint index1 = indexBuffer.indices[firstTriangleIndexNumber + 1];
    vec3 vertexPosition1 = getVertexPositionAtIndex(index1);

    uint index2 = indexBuffer.indices[firstTriangleIndexNumber + 2];
    vec3 vertexPosition2 = getVertexPositionAtIndex(index2);

    vec3 triangleNormal = computeTriangleNormal(vertexPosition0, vertexPosition1, vertexPosition2);

    // Output
    addVertexNormalAtIndex(index, triangleNormal * triangleArea(vertexPosition0, vertexPosition1, vertexPosition2));
}