#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0, rgba32f) uniform image2D outputImage;
layout(binding = 1, set = 0, rgba32f) uniform image2D inputImage;
layout(binding = 2, set = 0) uniform sampler3D noiseTexture;
layout(binding = 3, set = 0) uniform uniformBuffer
{
    uint noiseIdx;
    uint ditherX;
    uint ditherY;
    uint frameIdx;

    uint screenOffsetX;
    uint screenOffsetY;
    uvec2 padding;
} ub;

struct Payload
{
    float hitDistance;
    vec3 normal;
    vec3 albedo;
    float roughness;
    float metalness;
    mat3 TBN;
};
layout(location = 0) rayPayloadEXT Payload payload;

const float PI = 3.14159265359;

const uint DITHER_SIZE = 4;
const uint NOISE_TEXTURE_SIZE_PER_SIDE = 128;
const uint NOISE_TEXTURE_VECTOR_COUNT = 128;
const uint MAX_BOUNCE_COUNT = 4;
const uint NOISE_VECTOR_COUNT_PER_BOUNCE = NOISE_TEXTURE_VECTOR_COUNT / MAX_BOUNCE_COUNT;

float DistributionGGX(vec3 N, vec3 H, float roughness);
float GeometrySchlickGGX(float NdotV, float roughness);
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);
vec3 fresnelSchlick(float cosTheta, vec3 F0);

vec3 computeBRDF(in vec3 V, in vec3 normal, in float roughness, in vec3 F0, in vec3 albedo, in float metalness, in vec3 L)
{
    vec3 H = normalize(V + L);

    float NDF = DistributionGGX(normal, H, roughness);
    float G   = GeometrySmith(normal, V, L, roughness);
    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);

    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metalness;

    vec3 nominator    = NDF * G * F;
    float denominator = 4 * max(dot(normal, V), 0.0) * max(dot(normal, L), 0.0);
    vec3 specular     = nominator / max(denominator, 0.001);

    float NdotL = max(dot(normal, L), 0.0);
    return (kD * albedo / PI + specular) * NdotL;
}

vec3 computeRadianceForLight(in vec3 V, in vec3 normal, in float roughness, in vec3 F0, in vec3 albedo, in float metalness, in vec3 L, in vec3 color)
{
    vec3 brdf = computeBRDF(V, normal, roughness, F0, albedo, metalness, L);
    return brdf * color;
}

vec4 computeLighting(vec3 albedo, vec3 normal, float roughness, float metalness, vec3 worldPos, vec3 destinationPos)
{
    vec3 V = normalize(destinationPos - worldPos);

    vec3 F0 = vec3(0.04);
    F0 = mix(F0,albedo, metalness);

    vec3 Lo = vec3(0.0);

    vec3 L = normalize(-ubLights.sunLights[0].sunDirection.xyz);
    vec3 H = normalize(V + L);

    Lo += computeRadianceForLight(V, normal, roughness, F0, albedo, metalness, L, ubLights.sunLights[0].sunColor.xyz);

    return vec4(Lo, 1.0);
}

vec3 computeSunColor(vec3 direction)
{
    float sunCoeff = 0.0;
    vec3 sunColor = ubLights.sunLights[0].sunColor.rgb;

    float angleWithSun = 1.0 - dot(direction.xyz, normalize(-ubLights.sunLights[0].sunDirection.xyz));
    if (angleWithSun < 0.005)
        sunCoeff = (1.0 - (angleWithSun / 0.005));

    if (sunCoeff < 0.0005)
    {
        sunCoeff = 0.0005;
        sunColor = vec3(0.53, 0.8, 0.92);
    }

    //return sunColor * sunCoeff;

    return texture(CubeMap, normalize(direction)).xyz;
}

const float FINAL_COLOR_MULTIPLIER = 25.0;

void main() 
{
    uvec2 renderXY = uvec2(gl_LaunchIDEXT.x + ub.screenOffsetX, gl_LaunchIDEXT.y + ub.screenOffsetY);

    if (renderXY.x % DITHER_SIZE != ub.ditherX || renderXY.y % DITHER_SIZE != ub.ditherY)
        return;

    const vec2 pixelPos = vec2(gl_LaunchIDEXT.xy);
    const vec2 inUV = pixelPos / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = getInvViewMatrix() * vec4(0, 0, 0, 1);
    vec4 target = getInvProjectionMatrix() * vec4(d.x, d.y, 1, 1) ;
    vec3 direction = (getInvViewMatrix() * vec4(normalize(target.xyz), 0)).xyz;

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 1000.0;

    traceRay(rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, origin.xyz, tmin, direction.xyz, tmax);

    // First ray hit the sky
    if (payload.hitDistance > tmax)
    {
        vec3 sunColor = computeSunColor(direction.xyz);

        imageStore(outputImage, ivec2(renderXY.xy), vec4(sunColor.rgb, 1.0));
        return;
    }

    vec3 finalColor = vec3(0.0);

    vec3 destinationPos = getInvViewMatrix()[3].xyz;

    vec3 cumulatedBRDF = vec3(1.0);
    for (uint boundIdx = 0; boundIdx < MAX_BOUNCE_COUNT; boundIdx++)
    {
        vec3 hitPos = origin.xyz + payload.hitDistance * normalize(direction.xyz);
        origin.xyz = hitPos;
        vec3 hitAlbedo = payload.albedo.rgb;
        vec3 hitNormal = payload.normal.rgb;
        float hitRoughness = payload.roughness;
        float hitMetalness = payload.metalness;

        vec3 noiseDir = (texture(noiseTexture, vec3((gl_LaunchIDEXT.xy) / float(NOISE_TEXTURE_SIZE_PER_SIDE), float(ub.noiseIdx + boundIdx * NOISE_VECTOR_COUNT_PER_BOUNCE) / float(NOISE_TEXTURE_VECTOR_COUNT))).rbg); // b and g are inverted to make vertical = z
        noiseDir = noiseDir * payload.TBN;
        direction.xyz = normalize(noiseDir);

        traceRay(rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, hitPos, tmin, direction.xyz, tmax);

        vec3 F0 = vec3(0.04);
        F0 = mix(F0, hitAlbedo, hitMetalness);
        if (payload.hitDistance > tmax)
        {
            vec3 sunColor = computeSunColor(direction.xyz);
            
            vec3 hitColor = computeRadianceForLight(normalize(destinationPos - hitPos), hitNormal, hitRoughness, F0, hitAlbedo, hitMetalness, normalize(direction.xyz), sunColor);
            finalColor = hitColor * cumulatedBRDF;

            break;
        }

        vec3 newHitPos = origin.xyz + payload.hitDistance * normalize(direction.xyz);
        cumulatedBRDF *= computeBRDF(normalize(destinationPos - hitPos), hitNormal, hitRoughness, F0, hitAlbedo, hitMetalness, normalize(newHitPos - hitPos));
        destinationPos = hitPos;
    }

    finalColor *= FINAL_COLOR_MULTIPLIER;

    if (ub.frameIdx > 0)
    {
        vec4 previousColor = imageLoad(inputImage, ivec2(renderXY.xy)).rgba;
        finalColor = previousColor.rgb + (finalColor.rgb - previousColor.rgb) / float(ub.frameIdx);
    }

    // vec4 previousColor = imageLoad(inputImage, ivec2(gl_LaunchIDEXT.xy));
    // float coeff = 0.01;
    // finalColor = previousColor.bgr * (1.0 - coeff) + finalColor.rgb * coeff;

    imageStore(outputImage, ivec2(renderXY.xy), vec4(finalColor.rgb, 1.0));
}


float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return nom / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
	return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}