#extension GL_EXT_ray_tracing : require
#extension GL_EXT_samplerless_texture_functions : require

layout(std430, binding = 0, set = 0) buffer VoxelGridLayout
{
    vec3 values[];
} voxelGrid;

layout(binding = 1, set = 0) uniform UniformBuffer
{
    uint frameIdx;
    vec3 padding;
} ub;
layout(binding = 2, set = 0) uniform sampler3D noiseTexture;

layout(std430, binding = 3, set = 0) buffer VoxelRequestLayout
{
    uint values[];
} voxelRequest;

#include "payloads.glsl"
layout(location = 0) rayPayloadEXT FirstRayPayload payload;

const vec3 FIRST_PROBE_POS = vec3(-16.0f, -5.0f, -16.0f);
const float SPACE_BETWEEN_PROBES = 1.0f;

const uint GRID_SIZE = 32;

const vec3 DIRECTIONS[] = {
    vec3(1, 0, 0),
    vec3(-1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, -1, 0),
    vec3(0, 0, 1),
    vec3(0, 0, -1)
};

const uint NOISE_TEXTURE_SIZE_PER_SIDE = 128;
const uint NOISE_TEXTURE_VECTOR_COUNT = 128;
const uint RAY_COUNT_PER_ACTIVATED_FACE = 32;

bool checkIfFaceIsRequestedAndReset(in uint requestValueIdx, in uint firstRequestBitIdx, in uint bitOffset)
{
    if (firstRequestBitIdx + bitOffset >= 32)
    {
        requestValueIdx++;
        bitOffset = (firstRequestBitIdx + bitOffset) - 32;
        firstRequestBitIdx = 0;
    }

    uint bitIdx = 1 << (firstRequestBitIdx + bitOffset);
    bool valueToReturn = (voxelRequest.values[requestValueIdx] & bitIdx) != 0u;

    if (valueToReturn)
    {
        atomicAnd(voxelRequest.values[requestValueIdx], ~bitIdx);
    }

    return valueToReturn;
}

void main() 
{
    uvec3 probeCoords = uvec3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, gl_LaunchIDEXT.z);
    uint voxelIdx = probeCoords.x + probeCoords.y * GRID_SIZE + probeCoords.z * GRID_SIZE * GRID_SIZE;
    //vec3 probePos = FIRST_PROBE_POS + SPACE_BETWEEN_PROBES * vec3(probeCoords.x, probeCoords.y, probeCoords.z);

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 1000.0;

    uint requestValueIdx = (6 * voxelIdx) / 32;
    uint firstRequestBitIdx = (6 * voxelIdx) % 32;

    for (uint faceIdx = 0; faceIdx < 6; ++faceIdx)
    {
        if (!checkIfFaceIsRequestedAndReset(requestValueIdx, firstRequestBitIdx, faceIdx))
            continue;

        vec3 probePos = voxelGrid.values[voxelIdx * 12 + 6 + faceIdx];

        vec3 n = DIRECTIONS[faceIdx];
        vec3 t = abs(n.x) == 1.0 ? vec3(0, 1, 0) : vec3(1, 0, 0);
        vec3 b = cross(n, t);

        mat3 TBN = transpose(mat3(t, b, n));

        vec3 finalColor = vec3(0.0);
        for (uint rayIndex = 0; rayIndex < RAY_COUNT_PER_ACTIVATED_FACE; ++rayIndex)
        {
            uint noiseIdx = ub.frameIdx % NOISE_TEXTURE_VECTOR_COUNT;
            
            vec2 coordsForNoise = vec2(gl_LaunchIDEXT.xy) + vec2(rayIndex, 0);
            if (coordsForNoise.x > float(NOISE_TEXTURE_SIZE_PER_SIDE))
                coordsForNoise.x -= float(NOISE_TEXTURE_SIZE_PER_SIDE);

            vec3 noiseDir = (texture(noiseTexture, vec3(coordsForNoise / float(NOISE_TEXTURE_SIZE_PER_SIDE), float(noiseIdx) / float(NOISE_TEXTURE_VECTOR_COUNT))).rbg); // b and g are inverted to make vertical = z
            noiseDir = noiseDir * TBN;
            vec3 direction = normalize(noiseDir);

            if (dot(direction, normalize(-ubLights.sunLights[0].sunDirection.xyz)) > 0.98) // TODO: the 0.98 should come from sun radius
                continue;

            payload.evaluatedNormal = n;
            payload.rayIdx = 0;
            traceRay(rayFlags, cullMask, 0 /*sbtRecordOffset*/, 2 /*sbtRecordStride*/, 0 /*missIndex*/, probePos.xyz, tmin, direction.xyz, tmax);

            vec3 radiance;
            if (payload.hit)
            {
                vec3 L = normalize(-ubLights.sunLights[0].sunDirection.xyz);

                uint rayFlags = gl_RayFlagsOpaqueEXT;
                uint cullMask = 0xff;
                float tmin = 0.001;
                float tmax = 1000.0;
                payload.rayIdx = 1;
                payload.isShadowed = false;
                traceRay(rayFlags, cullMask, 0 /*sbtRecordOffset*/, 2 /*sbtRecordStride*/, 0 /*missIndex*/, payload.hitWorldPos.xyz, tmin, L, tmax);

                if (payload.isShadowed)
                {
                    radiance = vec3(0.0);
                }
                else
                {
                    radiance = payload.radiance;
                }
            }
            else
            {
                radiance = payload.radiance;
            }
            
            finalColor += radiance / float(RAY_COUNT_PER_ACTIVATED_FACE);
        }
       
        if (ub.frameIdx > 0)
        {
            vec3 previousColor = voxelGrid.values[voxelIdx * 12 + faceIdx].rgb;
            //finalColor = previousColor.rgb + (finalColor.rgb - previousColor.rgb) / float(ub.frameIdx);
            float currentResultWeight = 1.0 / 128.0;
            finalColor = finalColor * currentResultWeight + previousColor * (1.0 - currentResultWeight);
        }

        voxelGrid.values[voxelIdx * 12 + faceIdx] = finalColor;
    }
}