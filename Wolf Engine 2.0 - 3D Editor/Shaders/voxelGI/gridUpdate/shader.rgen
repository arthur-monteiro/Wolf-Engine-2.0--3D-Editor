#extension GL_EXT_ray_tracing : require
#extension GL_EXT_samplerless_texture_functions : require

layout(std430, binding = 0, set = 0) buffer VoxelGridLayout
{
    vec3 irradiances[];
} voxelGrid;

layout(binding = 1, set = 0) uniform UniformBuffer
{
    uint frameIdx;
    vec3 padding;
} ub;
layout(binding = 2, set = 0) uniform sampler3D noiseTexture;

layout(std430, binding = 3, set = 0) buffer VoxelRequestLayout
{
    uint values[];
} voxelRequest;

struct Payload
{
    vec3 radiance;
};
layout(location = 0) rayPayloadEXT Payload payload;

const vec3 FIRST_PROBE_POS = vec3(-10.0f, -5.0f, -10.0f);
const float SPACE_BETWEEN_PROBES = 1.0f;

const uint GRID_SIZE = 32;

const vec3 DIRECTIONS[] = {
    vec3(1, 0, 0),
    vec3(-1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, -1, 0),
    vec3(0, 0, 1),
    vec3(0, 0, -1)
};

const uint NOISE_TEXTURE_SIZE_PER_SIDE = 128;
const uint NOISE_TEXTURE_VECTOR_COUNT = 128;
const uint RAY_COUNT_PER_ACTIVATED_PIXEL = 16;

bool checkIfFaceIsRequestedAndReset(in uint requestValueIdx, in uint firstRequestBitIdx, in uint bitOffset)
{
    if (firstRequestBitIdx + bitOffset >= 32)
    {
        requestValueIdx++;
        bitOffset = (firstRequestBitIdx + bitOffset) - 32;
        firstRequestBitIdx = 0;
    }

    uint bitIdx = 1 << (firstRequestBitIdx + bitOffset);
    bool valueToReturn = (voxelRequest.values[requestValueIdx] & bitIdx) != 0u;

    if (valueToReturn)
    {
        atomicAnd(voxelRequest.values[requestValueIdx], ~bitIdx);
    }

    return valueToReturn;
}

void main() 
{
    uvec3 probeCoords = uvec3(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, gl_LaunchIDEXT.z);
    uint voxelIdx = probeCoords.x + probeCoords.y * GRID_SIZE + probeCoords.z * GRID_SIZE * GRID_SIZE;
    vec3 probePos = FIRST_PROBE_POS + SPACE_BETWEEN_PROBES * vec3(probeCoords.x, probeCoords.y, probeCoords.z);

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 1000.0;
    vec3 origin = probePos;

    uint requestValueIdx = (6 * voxelIdx) / 32;
    uint firstRequestBitIdx = (6 * voxelIdx) % 32;

    for (uint faceIdx = 0; faceIdx < 6; ++faceIdx)
    {
        if (!checkIfFaceIsRequestedAndReset(requestValueIdx, firstRequestBitIdx, faceIdx))
            continue;

        vec3 n = DIRECTIONS[faceIdx];
        vec3 t = abs(n.x) == 1.0 ? vec3(0, 1, 0) : vec3(1, 0, 0);
        vec3 b = cross(n, t);

        mat3 TBN = transpose(mat3(t, b, n));

        vec3 finalColor = vec3(0.0);
        for (uint rayIndex = 0; rayIndex < RAY_COUNT_PER_ACTIVATED_PIXEL; ++rayIndex)
        {
            uint noiseIdx = ub.frameIdx % NOISE_TEXTURE_VECTOR_COUNT;
            
            vec2 coordsForNoise = vec2(gl_LaunchIDEXT.xy) + vec2(rayIndex, 0);
            if (coordsForNoise.x > float(NOISE_TEXTURE_SIZE_PER_SIDE))
                coordsForNoise.x -= float(NOISE_TEXTURE_SIZE_PER_SIDE);

            vec3 noiseDir = (texture(noiseTexture, vec3(coordsForNoise / float(NOISE_TEXTURE_SIZE_PER_SIDE), float(noiseIdx) / float(NOISE_TEXTURE_VECTOR_COUNT))).rbg); // b and g are inverted to make vertical = z
            noiseDir = noiseDir * TBN;
            vec3 direction = normalize(noiseDir);

            if (dot(direction, normalize(-ubLights.sunLights[0].sunDirection.xyz)) > 0.98) // TODO: the 0.98 should come from sun radius
                continue;

            traceRay(rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, origin.xyz, tmin, direction.xyz, tmax);

            finalColor += payload.radiance / float(RAY_COUNT_PER_ACTIVATED_PIXEL);
        }
       
        if (ub.frameIdx > 0)
        {
            vec3 previousColor = voxelGrid.irradiances[voxelIdx * 6 + faceIdx].rgb;
            //finalColor = previousColor.rgb + (finalColor.rgb - previousColor.rgb) / float(ub.frameIdx);
            float currentResultWeight = 1.0 / float(NOISE_TEXTURE_VECTOR_COUNT);
            finalColor = finalColor * currentResultWeight + previousColor * (1.0 - currentResultWeight);
        }

        voxelGrid.irradiances[voxelIdx * 6 + faceIdx] = finalColor;
    }
}